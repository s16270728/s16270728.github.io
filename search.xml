<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KM寫作教學]]></title>
    <url>%2F2018%2F04%2F30%2FKM%E5%AF%AB%E4%BD%9C%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[簡介XDM KM平台以及寫作文件的方法和工具 KM平台簡介KM平台為靜態網站，使用HEXO建置，可以輕易建立在各種環境。 在主畫面上方為選單列 首頁: 顯示近期文章以及文章的簡介 歸檔: 以清單方式用日期排序顯示文章標題 標籤: 顯示所有文章標籤 分類: 顯示所有文章分類 搜尋: 搜尋工具，可搜尋標題以及內文 文章畫面左邊為主要內容，右方為章節列，可快速跳選文章位置 寫作工具文件的寫作語法為Markdown，相關語法可以參考Markdown教學 提供線上以及本機的工具供參考 線上: StackEdit 本機: Visual Studio Code StackEdit線上版Markdown編輯器，主畫面左邊為語法編輯區右邊為預覽區，左上方提供檢視格式工具幫助產生語法 Visual Studio Code微軟提供的輕量級編輯器，支援多種語法包含Markdown 打開md文件後在右上方可以找到預覽按鈕，可以顯示預覽畫面 寫作方法使用VsCode當作範例建立一份文章。 建立文章儲存區建立一個資料夾，md檔以及你文章內所有會連結到的圖片以及檔案將會放在同一個資料夾下 一個資料夾只會有一個md檔也代表一篇文章 使用VsCode編輯可以在主畫面選擇開啟資料夾或著從左上方選單的檔案裡選擇開啟資料夾功能 文章格式因為要規範文章分類以及標籤等內容，有些預設的文章格式需要遵守 下面提供範本 --- title: Sample date: 2018-04-25 18:04:19 updated: 2018-04-30 18:04:19 categories: - [其他文件, Sample] tags: - 其他文件 - 其他文件2 --- &gt; Author：Sid ![logo](logo.png) more以上的內容為文章縮寫內容，more以下會在文章內容出現 &lt;!-- more --&gt; 其他內容 title: 標題名稱 date: 寫作建立日期 updated: 寫作更新日期 categories: 可以為單一分類，也可以多個分類，也可以多層階級關係 有階層關係使用方括號[ 分類1, 分類1-1 ]，類似此方法 tags: 文章標籤，可多個 &gt; Author: 填寫文章作者 &lt;!-- more --&gt;: 文章縮寫分界線，建議要使用 貼圖語法由於檔案跟md檔在同一目錄，所以語法直接填寫檔案名稱![logo](logo.png)預覽就可以直接看到圖 壓縮寄出文章寫好後應該會準備好一個資料夾裡面放著md檔以及圖片、附件，然後將整個資料夾壓縮後寄出至XDM PD組，暫由PD負責上架。]]></content>
      <categories>
        <category>其他教學文件</category>
        <category>KM</category>
      </categories>
      <tags>
        <tag>新手教學</tag>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Forms開發初階教學]]></title>
    <url>%2F2018%2F04%2F26%2FWindowsForms%E9%96%8B%E7%99%BC%E5%88%9D%E9%9A%8E%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[這篇教學從建立Windows Froms開始到建立一些控制項設定屬性等的基礎教學 簡介Windows Forms是微軟的.NET開發框架的圖形用戶介面的一部分 使用 Windows Form 來開發智慧型用戶端。 「智慧型用戶端」是豐富的圖形化應用程式，容易部署及更新，無論是否連接至網際網路都能運作，而且在存取本機電腦上的資源時，所使用的方法比傳統的 Windows 應用程式更安全。 微軟在.Net 3.0中發行了支援影片加速的Windows Presentation Foundation（簡稱WPF）作為Windows Forms的替代版本，但是WPF並不能完全取代Windows Forms，很多時候仍需要和Windows Forms互操作。 建立Windows Forms應用程式在功能表列上，選擇 [檔案] 、[新增] 、[專案] 。 對話方塊看起來會像這樣。 建立完之後VS視窗大概會有這樣的配置 主要有主視窗、方案總管和 [屬性] 視窗。 主視窗：您將在這個視窗中進行大部分的工作，例如，使用表單和編輯程式碼。 在圖中，視窗在 [表單編輯器] 中顯示表單。 視窗頂端會出現 [起始頁] 索引標籤和 [Form1.cs [Design]] 索引標籤 (在 Visual Basic 中，索引標籤名稱的結尾是 .vb，而不是 .cs)。 方案總管視窗：在這個視窗中，您可以檢視和巡覽至方案中的所有項目。 如果您選擇一個檔案，[屬性] 視窗的內容會隨著變更。 如果您開啟程式碼檔 (在 Visual C# 中結尾 .cs，在 Visual Basic 中則是 .vb)，程式碼檔或程式碼檔的設計工具隨即出現。 設計工具是一個視覺化介面，您可以將控制項 (例如按鈕和清單) 加入該介面中。 Visual Studio 表單的設計工具稱為 Windows Form 設計工具。 屬性視窗：在這個視窗中，您可以變更在其他視窗中所選擇項目的屬性。 例如，如果您選擇 Form1，可以設定 Text 屬性變更其標題，也可以設定 Backcolor 屬性變更背景色彩。 接著執行你的程式，有以下幾種方法 選擇 F5 鍵。 在功能表列上，選擇 [偵錯]、[開始偵錯]。 在工具列上選擇 [開始偵錯] 按鈕。 執行成功後應該就會看到一個空白的視窗程式 使用下列其中一種方法停止您的程式。 在工具列上選擇 [停止偵錯] 按鈕。 在功能表列上，選擇 [偵錯]、[停止偵錯]。 選擇 [Form1] 視窗右上角的 X 按鈕。 開發環境架構介紹首先從你的設計畫面中點選Form，然後在右邊找到你的屬性視窗看起來應該如下圖 選取之後，在 [屬性] 視窗中尋找 [Text] 屬性 打上名稱，你的Form名稱就會改變 當拖曳Form邊邊角角的小方塊時可以調整大小，此時在屬性視窗的Size也會跟著改變，也可以直接在Size屬性直接填寫寬度高度 所以各個控制項基本上透過2個方法來設定 透過IDE的設計畫面或屬性視窗直接做設定 在.cs檔透過程式碼來改變設定 在方案總管可以看到目前我們的架構很簡單只有一個Form1跟Program.cs和App.config Form1 : Form元件，可以自行產生多個自訂的Form來交互使用 Program.cs : 程式的進入點 App.config : 程式的設定檔 一個Form包含兩個檔案.cs以及.Designer.cs，前者為程式邏輯撰寫的地方，後者為UI設計的程式碼 VS對於Winform開發提供了視覺化設計介面讓開發者可以直接對畫面做調整，不需要全部透過程式碼來實現。 VS左側可以找到工具箱，裡面提供許多.NET平台配件的UI控制項，也可以自行開發在工具箱引入讓其他開發人員使用。 開發練習現在簡單的做個練習，做一個小程式裡面有輸入框以及按鈕，讓使用者輸入文字然後產生在下面訊息視窗 建立表單Layout首先從工具箱中找到TableLayoutPanel，拖曳到Form裡面，這是一個網格類型的排版控制項，可以幫助我們配置Form的版面 接著我們將TableLayoutPanel的Dock屬性設為Fill，讓他的大小跟隨著父容器縮放。 我們只需要兩列的配置，所以接下來將TableLayoutPanel的兩行兩列改為一行兩列 點選TableLayoutPanel然後控制項右上角會浮現一個小三角形符號，點選可以出現控制項的設置，這裡點擊編輯資料列與資料行，參考下方設定。 將Column刪掉一個，並將剩餘的一個大小設為100% 將第一個Row大小改為絕對並設為50px，第二個Row設為100% 加入控制項TableLayoutPanel裡面一個空間只能容許放入一個控制項，所以需要加入Panel讓我們可以放多個控制項在裡面 控制項的關係就會變成TableLayoutPanel=&gt; Panel =&gt; Controls 將Panel加入到第一個Row 將Panel的Dock設為Fill 在來我們需要一個輸入框以及按鈕 將TextBox加入Panel 將Button加入Panel 直接在設計畫面中調整大小以及為置 接著我們對這兩個控制項做一些設定 TextBox的(Name)取為inputTextBox TextBox的Anchor設為 Top, Left, Right Button的(Name)取為sendMessageButton Button的Text設為送出 Button的Anchor設為 Right 最後我們在加入一個新的TextBox到第二條Row，一樣做一些設定 (Name)取為messageTextBox Multiline設為True (讓textbox可以輸入多行文字) Dock設為Fill ReadOnly設為True (讓textbox只能看不能編輯) 最後執行你的程式，外觀應該會大約是這個樣子 程式邏輯以及事件接下來我們就要在Form中加入一些程式碼以及事件 首先我們要為送出的按鈕加入點擊的事件，讓送出按鈕被點擊時可以觸發我們的程式碼 控制項基本上都會附有許多的event，讓使用者在程式互動時可以傳出event，而開發者就可以程式碼寫在event裡，控制被觸發時要執行甚麼動作 有兩種方法可以讓程式碼自動產生Button的點擊事件 在設計畫面直接雙擊Button，就會自動預設產生Click事件 點擊Button在屬性視窗裡點事件分頁的選項找到Click事件在右邊空白的設定雙擊 事件分頁裡的事件設定可以選擇程式碼中已經寫好的方法，或著雙擊由系統自動產生 產生事件後你應該會看到Form1.cs中自動加入了下列程式碼 方法中的sender 和 e 參數為事件回傳參數，由事件發起者傳入 private void sendMessageButton_Click(object sender, EventArgs e) { } 可以在Click的方法中加入 MessageBox.Show(&quot;Botton is clicked&quot;); 執行程式然後點擊送出按鈕來測試一下是否有成功的觸發事件 以上簡單的操作就可以快速產生一個送出按鈕被點擊的事件 private void sendMessageButton_Click(object sender, EventArgs e) { //取得輸入的文字 var input = this.inputTextBox.Text; if (string.IsNullOrWhiteSpace(input)) //如果沒輸入名字出現提示訊息 { MessageBox.Show(&quot;Input is null!&quot;); } else //有輸入將訊息傳至messageTextBox { this.messageTextBox.Text += $&quot;{DateTime.Now:yyyy/MM/dd HH:mm:ss} : {input} {Environment.NewLine}&quot;; } } 程式執行結果 當在文字輸入框輸入文字後點送出按鈕會將輸入內容加至下方訊息框 Oracle 資料庫連線現在示範如何跟Oracle資料庫連線，以往.NET平台與Oracle的連線設定常常會遇到一些相容問題，就是大家常用的Oracle.DataAccess(ODP.NET)。 Oracle近年有提供新的連線工具 Managed ODP.NET，讓.Net平台輕鬆可以與Oracle連線，不用安裝Oracle Client，還可以使用Entity。 ================ 第一步我們要在專案中加入Oracle.ManagedDataAccess，首先在方案總管的專案上按右鍵選擇管理Nuget套件 接著切到瀏覽畫面然後在搜尋列輸入oracle找到Oracle.ManagedDataAccess選擇安裝，此時就完成加入專案 接著參考下列與法與資料庫連線取得資料 //連線字串，主要修改幾個地方 HOST=你的資料庫IP PORT=你的資料庫TCP通道 然後填入SID USER ID PASSWORD string connectionString = &quot;DATA SOURCE=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.1.13)(PORT=1521)))(CONNECT_DATA=(SID = yms)))PERSIST SECURITY INFO=True;USER ID=yms;PASSWORD=admin;&quot;; //:GROUPNAME 代表參數從Parameters傳入，參數名稱GROUPNAME，這種作法可防止SQL Injection(資料隱碼攻擊) string sqlCommand = &quot;SELECT GROUP_NAME,SRC_TABLE_NAME,TRG_TABLE_NAME FROM XDM_TABLE_REP_CFG &quot; + &quot;WHERE GROUP_NAME=:GROUPNAME&quot;; //建立連線 using (OracleConnection conn = new OracleConnection(connectionString)) { if (conn.State == ConnectionState.Closed) { conn.Open(); } //建立SQL Command OracleCommand cmd = new OracleCommand(sqlCommand, conn); //BindByName預設為false，SQL會依照順序代入參數 //若設為true時，則依參數名稱代入參數 cmd.BindByName = true; //加入參數 cmd.Parameters.Clear(); cmd.Parameters.Add(&quot;GROUPNAME&quot;, &quot;ARYODS&quot;); //執行Select Command OracleDataAdapter DataAdapter = new OracleDataAdapter(); DataAdapter.SelectCommand = cmd; //將資料存入DataTable DataTable dt = new DataTable(); DataAdapter.Fill(dt); }]]></content>
      <categories>
        <category>程式開發教學</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>新手教學</tag>
        <tag>WinForms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL初階教學2]]></title>
    <url>%2F2018%2F04%2F26%2FSQL%E5%88%9D%E9%9A%8E%E6%95%99%E5%AD%B82%2F</url>
    <content type="text"><![CDATA[延續SQL初階教學教學文件 在之前的教學文件中介紹了基本資料的選取、篩選、函數、分組的使用 這篇主要在表格連接的介紹 表格連接 JOIN當要把多個表格資料連接在一起的時候要使用到JOIN的概念 假設我們要根據CUSTOMER資料表來看每個客戶他有哪些ORDERS 有以下幾種JOIN的方式 INNER JOIN 內部連接 LEFT (OUTER) JOIN 左外部連接 RIGHT (OUTER) JOIN 右外部連接 FULL (OUTER) JOIN 全部外部連接 CROSS JOIN 交叉連接 (少用) NATURAL JOIN 自然連接 (少用) INNER JOININNER JOIN (也可以只寫JOIN)查詢結果返回符合連接條件的資料，兩邊資料都有對應到才回取得 SELECT * FROM CUSTOMER C INNER JOIN ORDERS O ON C.ACCOUNT = O.CUSTOMER_ACCOUNT SELECT * FROM CUSTOMER C, ORDERS O WHERE C.ACCOUNT = O.CUSTOMER_ACCOUNT 結果應該會看到14筆資料，ORDERS裡面有14筆資料可以對應到CUSTOMER資料 LEFT (OUTER) JOINLEFT JOIN 可以用來建立左外部連接，查詢的 SQL 敘述句 LEFT JOIN 左側資料表 (table_name1) 的所有記錄都會加入到查詢結果中，即使右側資料表 (table_name2) 中的連接欄位沒有符合的值也一樣。 SELECT * FROM CUSTOMER C LEFT JOIN ORDERS O ON C.ACCOUNT = O.CUSTOMER_ACCOUNT Oracle可以在WHERE語句中加上(+)，代表這個表格不管有沒有資料都要 SELECT * FROM CUSTOMER C, ORDERS O WHERE C.ACCOUNT = O.CUSTOMER_ACCOUNT(+) 結果16筆資料，有2筆客戶是沒有ORDERS資料的 RIGHT (OUTER) JOIN相對於 LEFT JOIN，RIGHT JOIN 可以用來建立右外部連接，查詢的 SQL 敘述句 RIGHT JOIN 右側資料表 (table_name2) 的所有記錄都會加入到查詢結果中，即使左側資料表 (table_name2) 中的連接欄位沒有符合的值也一樣。 SELECT * FROM CUSTOMER C RIGHT JOIN ORDERS O ON C.ACCOUNT = O.CUSTOMER_ACCOUNT Oracle可以在WHERE語句中加上(+)，代表這個表格不管有沒有資料都要 SELECT * FROM CUSTOMER C, ORDERS O WHERE C.ACCOUNT(+) = O.CUSTOMER_ACCOUNT 結果15筆資料，有1筆ORDERS的客戶ACCOUNT不存在於CUSTOMER表格 FULL JOINFULL JOIN 即為 LEFT JOIN 與 RIGHT JOIN 的聯集，它會返回左右資料表中所有的紀錄，不論是否符合連接條件。 SELECT * FROM CUSTOMER C FULL JOIN ORDERS O ON C.ACCOUNT = O.CUSTOMER_ACCOUNT 結果17筆資料 CROSS JOIN交叉連接為兩個資料表間的笛卡兒乘積 (Cartesian product)，兩個資料表在結合時，不指定任何條件，即將兩個資料表中所有的可能排列組合出來，以下例而言 CROSS JOIN 出來的結果資料列數為 3×5=15 筆，因此，當有 WHERE、ON、USING 條件時不建議使用。 SELECT table_column1, table_column2… FROM table_name1 CROSS JOIN table_name2; 下面簡單範例用CUSTOMER和PRODUCT的NAME做交叉乘開所有的組合 SELECT C.NAME,P.NAME FROM CUSTOMER C CROSS JOIN PRODUCT P 結果會是CUSTOMER 10筆 * PRODUCT 6筆 = 60筆 NATURAL JOIN自然連接有 NATURAL JOIN、NATURAL LEFT JOIN、NATURAL RIGHT JOIN，兩個表格在進行 JOIN 時，加上 NATURAL 這個關鍵字之後，兩資料表之間同名的欄位會被自動結合在一起。 SELECT table_column1, table_column2… FROM table_name1 NATURAL JOIN table_name2; 用不到 不示範了 資料處理CONCATENATE有的時候，我們有需要將由不同欄位獲得的資料串連在一起。每一種資料庫都有提供方法來達到這個目的： MySQL: CONCAT( ) Oracle: CONCAT( ), || SQL Server: + 把CUSTOMER的ACCOUNT和NAME欄位串起來成一個欄位 SELECT C.ACCOUNT||C.NAME FROM CUSTOMER C SUBSTRINGSQL 中的 SUBSTRING 函數是用來抓出一個欄位資料中的其中一部分。這個函數的名稱在不同的資料庫中不完全一樣： MySQL: SUBSTR( ), SUBSTRING( ) Oracle: SUBSTR( ) SQL Server: SUBSTRING( ) SUBSTR (str, pos) 以上語法的意思是，由 中，選出所有從第 位置開始的字元。請注意，這個語法不適用於SQL Server上。 SUBSTR (str, pos, len) 以上語法的意思是，由 中的第 位置開始，選出接下去的 個字元。 擷取字串時如果取不到會回傳NULL CUSTOMER的NAME只取前兩個字 SELECT SUBSTR(C.NAME,1,2) FROM CUSTOMER C CUSTOMER的NAME取第2個字後的所有字(包含2) SELECT SUBSTR(C.NAME,2) FROM CUSTOMER C TRIMSQL 中的 TRIM 函數是用來移除掉一個字串中的字頭或字尾。最常見的用途是移除字首或字尾的空白。這個函數在不同的資料庫中有不同的名稱： MySQL: TRIM( ), RTRIM( ), LTRIM( ) Oracle: RTRIM( ), LTRIM( ) SQL Server: RTRIM( ), LTRIM( ) TRIM ( [ [位置] [要移除的字串] FROM ] 字串): [位置] 的可能值為 LEADING (起頭), TRAILING (結尾), or BOTH (起頭及結尾)。 這個函數將把 [要移除的字串] 從字串的起頭、結尾，或是起頭及結尾移除。如果我們沒有列出 [要移除的字串] 是什麼的話，那空白就會被移除。 LTRIM (字串): 將所有字串起頭的空白移除。 RTRIM (字串): 將所有字串結尾的空白移除。 LENGTH在 SQL 中，長度函數是用來找出一個字串的長度。這個函數的名稱在不同的資料庫中不完全一樣： MySQL: LENGTH( ) Oracle: LENGTH( ) SQL Server: LEN( ) REPLACE在 SQL 中，Replace函數是用來改變一個字串的內容。這個函數在 MySQL、Oracle、及 SQL Server 上都是 Replace( )。這個函數的語法如下： Replace (str1, str2, str3) 以上語法的意思是，在字串 str1 中，當 str2 出現時，將其以 str3 替代。]]></content>
      <categories>
        <category>程式開發教學</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>新手教學</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL初階教學]]></title>
    <url>%2F2018%2F04%2F25%2FSQL%E5%88%9D%E9%9A%8E%E6%95%99%E5%AD%B81%2F</url>
    <content type="text"><![CDATA[此教學以Oracle環境為主，但基本SQL語法在大部分資料庫寫法都差異不大 以下教學內容可以在SQL Fiddle進行練習，或是自行準備資料庫環境 以SQL為基礎的其他延伸語言 Transact-SQL微軟MS SQL-Server，以及Sybase Adaptive Server系列資料庫所用的SQL PL-SQLOracle 資料庫所使用的SQL SQL Fiddle 練習環境SQL Fiddle 參考下圖，左上角紅色部分可以選擇要進行測試的DB環境是哪一種，中間藍色以及綠色為建立Table和執行SQL，下方橘色為執行結果以及查看執行計畫。 範例資料可以直接複製到SQL Fiddle左邊區塊然後點選Build Schema後，下方會看見schema ready的成功訊息 CREATE TABLE CUSTOMER (&quot;ACCOUNT&quot; varchar2(4), &quot;NAME&quot; varchar2(6), &quot;AGE&quot; int, &quot;GENDER&quot; char(1)) // INSERT ALL INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A001&#39;, &#39;Olivia&#39;, 18, &#39;0&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A002&#39;, &#39;Lily&#39;, 22, &#39;0&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A003&#39;, &#39;Emily&#39;, 50, &#39;0&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A004&#39;, &#39;Grace&#39;, 40, &#39;0&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A005&#39;, &#39;Ruby&#39;, 33, &#39;0&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A006&#39;, &#39;Ella&#39;, 22, &#39;0&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A007&#39;, &#39;Jack&#39;, 16, &#39;1&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A008&#39;, &#39;Teddy&#39;, 38, &#39;1&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A009&#39;, &#39;Oscar&#39;, 42, &#39;1&#39;) INTO CUSTOMER (&quot;ACCOUNT&quot;, &quot;NAME&quot;, &quot;AGE&quot;, &quot;GENDER&quot;) VALUES (&#39;A010&#39;, &#39;Leo&#39;, 55, &#39;1&#39;) SELECT * FROM dual // CREATE TABLE PRODUCT (&quot;ID&quot; varchar2(4), &quot;PRICE&quot; int, &quot;NAME&quot; varchar2(8)) // INSERT ALL INTO PRODUCT (&quot;ID&quot;, &quot;PRICE&quot;, &quot;NAME&quot;) VALUES (&#39;P001&#39;, 100, &#39;Apple&#39;) INTO PRODUCT (&quot;ID&quot;, &quot;PRICE&quot;, &quot;NAME&quot;) VALUES (&#39;P002&#39;, 200, &#39;Book&#39;) INTO PRODUCT (&quot;ID&quot;, &quot;PRICE&quot;, &quot;NAME&quot;) VALUES (&#39;P003&#39;, 300, &#39;Car&#39;) INTO PRODUCT (&quot;ID&quot;, &quot;PRICE&quot;, &quot;NAME&quot;) VALUES (&#39;P004&#39;, 400, &#39;Computer&#39;) INTO PRODUCT (&quot;ID&quot;, &quot;PRICE&quot;, &quot;NAME&quot;) VALUES (&#39;P005&#39;, 500, &#39;Phone&#39;) INTO PRODUCT (&quot;ID&quot;, &quot;PRICE&quot;, &quot;NAME&quot;) VALUES (&#39;P006&#39;, 700, &#39;House&#39;) SELECT * FROM dual // CREATE TABLE ORDERS (&quot;PRODUCT_ID&quot; varchar2(4), &quot;QUANTITY&quot; int, &quot;CUSTOMER_ACCOUNT&quot; varchar2(4), &quot;CREATEDTIME&quot; timestamp) // INSERT ALL INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P001&#39;, 1, &#39;A001&#39;, &#39;01-Jan-2018 10:00:00 AM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P001&#39;, 3, &#39;A001&#39;, &#39;01-Jan-2018 10:00:00 AM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P001&#39;, 2, &#39;A004&#39;, &#39;03-Jan-2018 10:00:00 AM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P001&#39;, 4, &#39;A002&#39;, &#39;03-Jan-2018 10:00:00 AM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P001&#39;, 5, &#39;A001&#39;, &#39;01-Jan-2018 10:00:00 AM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P002&#39;, 4, &#39;A003&#39;, &#39;02-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P002&#39;, 1, &#39;A001&#39;, &#39;02-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P003&#39;, 2, &#39;A008&#39;, &#39;03-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P003&#39;, 3, &#39;A007&#39;, &#39;03-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P003&#39;, 1, &#39;A006&#39;, &#39;02-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P004&#39;, 2, &#39;A005&#39;, &#39;02-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P005&#39;, 4, &#39;A001&#39;, &#39;04-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P002&#39;, 2, &#39;A008&#39;, &#39;04-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P002&#39;, 5, &#39;A003&#39;, &#39;05-Jan-2018 08:00:00 PM&#39;) INTO ORDERS (&quot;PRODUCT_ID&quot;, &quot;QUANTITY&quot;, &quot;CUSTOMER_ACCOUNT&quot;, &quot;CREATEDTIME&quot;) VALUES (&#39;P002&#39;, 5, &#39;A100&#39;, &#39;05-Jan-2018 08:00:00 PM&#39;) SELECT * FROM dual // 基本選取條件語法建立資料表 (Create)Create 語法格式[ ]內為option CREATE TABLE [schema.]table_name ( column datatype [DEFAULT value] [in_constraint_caluse] [,column datatype [DEFAULT value] [in_constraint_caluse]...] [,out_constraint_caluse] ) [partition_caluse] [TABLESPACE tablespace_name]; schema : 結構名稱 table_name : 表格名稱 column : 欄位名稱 datatype : 資料型態 value : 欄位預設值 tablespace_name : 表空間名稱 Oracle資料型別字符資料型別n為引數 CHAR[(n [BYTE | CHAR] )] : 固定長度字串資料型別 NCHAR[(n)] : 固定長度Unicode字串資料型別 VARCHAR2[(n [BYTE | CHAR] )] : 可變長度字串資料型別 NVARCHAR2(n) : 可變長度Unicode字串資料型別 CLOB : 字元大型物件(bigfile)資料型別 NCLOB : Unicode字元大型物件(bigfile)資料型別 數值資料型別n為引數n1為整數值幾位n2為小數點下幾位 NUMBER[(n1[,n2])] : 帶有精密度和位數的數值資料型別 FLOAT[(n)] : NUMBER的子型別 BINARY_FLOAT : 浮點數(32位元)資料型別 BINARY_DOUBLE : 浮點數(64位元)資料型別 日期時刻及期間資料型別n為引數 n1為日期的位數 n2為秒的小數部分位數 DATE : 日期格式 TIMESTAMP[(n)] : 日期和時間格式 TIMESTAMP[(n)] WITH TIME ZONE : 整個TIMESTAMP與時區及個世界地區時差 TIMESTAMP[(n)] WITH LOCAL TIME ZONE : 整個TIMESTAMP沒有世界地區時差 INTERVAL YEAR[(n)] TO MONTH : 期間(年月單位) INTERVAL DAY[(n1)] TO SECODE[(n2)] : 期間(日時分秒單位) 二進制資料型別size:RAW資料的位元組數 BLOB : 二進制大型物件(例如:影像檔,圖片檔) BFILE : 二進制檔案的定位符 RAW(size) : 二進制資料 ROWID資料型別n為資料型別長度 ROWID : 用來表示列位址的BASE64字串 UROWID[(n)] : 用來表示索引構成表格列之邏輯位址的BASE64字串 SELECT從表格中選取出資料 SELECT “欄位名” FROM “表格名”; SELECT FROM TABLE 代表所有欄位 取出所有客戶的名稱 SELECT NAME FROM CUSTOMER 如果希望取出來的資料可以更換名稱，可以為欄位取別名用法為欄位後面空一格填上名稱(需注意避開保留字) SELECT NAME USERNAME FROM CUSTOMER AA DISTINCT取出資料時排除重複的資料 SELECT DISTINCT “欄位名” FROM “表格名”; 取出ORDERS中不重複的CREATEDTIME SELECT DISTINCT CREATEDTIME FROM ORDERS WHERE選取資料時不一定都需要全部的資料，WHERE可以有條件的選取資料 基本的運算子有 &gt;、&gt;=、&lt;=、&lt;、=、&lt;&gt;(不等於) 常用的還有 IS NULL、 IS NOT NULL SELECT “欄位名” FROM “表格名” WHERE “條件”; 取出ORDERS中CUSTOMER_ACCOUNT為A001的資料 SELECT * FROM ORDERS WHERE CUSTOMER_ACCOUNT = &#39;A001&#39; AND、OR使用WHERE時可能條件不只一個，此時就要使用AND OR將條件串連起來，然後可以搭配( )來表示條件的先後順序 AND : 代表雙邊條件都要成立 OR : 雙邊條件其中一方成立 SELECT “欄位名” FROM “表格名” WHERE “簡單條件” {[AND|OR] “簡單條件”}+; 取出CUSTOMER為女性且AGE超過40或低於20 SELECT * FROM CUSTOMER WHERE GENDER = &#39;0&#39; AND (AGE &gt; 40 OR AGE &lt; 20) IN當WHERE的條件在同一個欄位一次比對多個值時可以使用IN將要比對的值都放入 SELECT “欄位名”FROM “表格名”WHERE “欄位名” IN (‘值一’, ‘值二’, …); 取出CUSTOMER的NAME為Olivia,Lily,Emily的資料 SELECT * FROM CUSTOMER WHERE NAME IN (&#39;Olivia&#39;,&#39;Lily&#39;,&#39;Emily&#39;) BETWEEN當WHERE對一個範圍下條件使用BETWEEN，條件類似&gt;=、&lt;= SELECT “欄位名” FROM “表格名” WHERE “欄位名” BETWEEN ‘值一’ AND ‘值二’; 取出CUSTOMER的AGE在30到50之間的資料 SELECT * FROM CUSTOMER WHERE AGE BETWEEN 30 AND 50 萬用字元有的時候，我們需要依照由字串模式中找出相符的資料。要滿足這個需求，我們就需要用到萬用字元 (wildcard) 的做法。SQL 中有兩個萬用字元： % (百分比符號)：代表零個、一個、或數個字母。 _ (底線)：代表剛好一個字母。 萬用字元是與 LIKE 關鍵字一起使用的。 以下是幾個萬用字元的例子： ‘A_Z’: 所有以 ‘A’ 起頭，另一個任何值的字原，且以 ‘Z’ 為結尾的字串。 ‘ABZ’ 和 ‘A2Z’ 都符合這一個模式，而 ‘AKKZ’ 並不符合 (因為在 A 和 Z 之間有兩個字元，而不是一個字元)。 ‘ABC%’: 所有以 ‘ABC’ 起頭的字串。舉例來說，’ABCD’ 和 ‘ABCABC’ 都符合這個模式。 ‘%XYZ’: 所有以 ‘XYZ’ 結尾的字串。舉例來說，’WXYZ’ 和 ‘ZZXYZ’ 都符合這個模式。 ‘%AN%’: 所有含有 ‘AN’這個模式的字串。舉例來說， ‘LOS ANGELES’ 和 ‘SAN FRANCISCO’ 都符合這個模式。 ‘_AN%’： 所有第二個字母為 ‘A’ 和第三個字母為 ‘N’ 的字串。舉例來說，’SAN FRANCISCO’ 符合這個模式，而 ‘LOS ANGELES’ 則不符合這個模式。 取出CUSTOMER中NAME含有’e’的資料 SELECT * FROM CUSTOMER WHERE NAME LIKE &#39;%e%&#39; ORDER BY對資料進行排序 ASC : 從小到大 DESC : 從大到小 沒有寫出的話預設為ASC SELECT “欄位名” FROM “表格名” [WHERE “條件”] ORDER BY “欄位名” [ASC, DESC]; 取出CUSTOMER用AGE從大到小排序 SELECT * FROM CUSTOMER ORDER BY AGE DESC 函數語法SQL有提供一些可以對數值欄位做計算的函數 AVG (平均) COUNT (計數) MAX (最大值) MIN (最小值) SUM (總合) SELECT “函數名”(“欄位名”) FROM “表格名”; AVG計算CUSTOMER的AGE平均 SELECT AVG(AGE) FROM CUSTOMER COUNT計算CUSTOMER的資料筆數 SELECT COUNT(*) FROM CUSTOMER COUNT 常搭配 DISTINCT來使用，用來計算此欄位有多少個不同的值 計算CUSTOMER中有多少筆不相同的NAME SELECT COUNT(DISTINCT NAME) FROM CUSTOMER MAX取得CUSTOMER的AGE中最大的值 SELECT MAX(AGE) FROM CUSTOMER MIN取得CUSTOMER的AGE中最小的值 SELECT MIN(AGE) FROM CUSTOMER SUM加總CUSTOMER的AGE SELECT SUM(AGE) FROM CUSTOMER GROUP BY上面那個計算函數都是針對選取出來的資料對全部做計算，我們可以使用GROUP BY將資料進行分組來做計算 SELECT “欄位1”, SUM(“欄位2”) FROM “表格名” GROUP BY “欄位1”; 取得CUSTOMER的AGE平均並且用GENDER來分組，這樣就可以看到男女的平均年齡比較 SELECT GENDER, AVG(AGE) FROM CUSTOMER GROUP BY GENDER HAVING對函數產生的值來設定條件 SELECT “欄位1”, SUM(“欄位2”) FROM “表格名” GROUP BY “欄位1” HAVING (函數條件); 在上面GROUP BY的例子我們可以看到根據GENDER分組計算出來的平均 現在只想看到計算出來結果大於35的資料 SELECT GENDER, AVG(AGE) FROM CUSTOMER GROUP BY GENDER HAVING AVG(AGE) &gt; 35 相關資料SQL初階教學2]]></content>
      <categories>
        <category>程式開發教學</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>新手教學</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment @font-face { font-family: Chunkfive; src: url(&#39;Chunkfive.otf&#39;); } body, .usertext { color: #F0F0F0; background: #600; font-family: Chunkfive, sans; } @import url(print.css); @media print { a[href^=http]::after { content: attr(href) } }]]></content>
      <categories>
        <category>不分類</category>
      </categories>
      <tags>
        <tag>不分類</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#初階教學2]]></title>
    <url>%2F2018%2F04%2F25%2FCsharp%E5%88%9D%E9%9A%8E%E6%95%99%E5%AD%B82%2F</url>
    <content type="text"><![CDATA[延續C#初階教學教學文件 類別與物件 (class, object)「類別」是 C# 最基本的型別。 類別是以單一單位結合狀態 (欄位) 和動作 (方法及其他函式成員) 的資料結構。 類別可以為動態建立的類別「執行個體」(稱為「物件」) 提供定義。 類別支援「繼承」和「多型」，這些是可供「衍生類別」將「基底類別」延伸及特製化的機制。 宣告一個Person類別 class Program { public class Person //類別 { /// &lt;summary&gt; /// 年齡 /// &lt;/summary&gt; public int Age { get; set; } //屬性 /// &lt;summary&gt; /// 增加年齡 /// &lt;/summary&gt; /// &lt;param name=&quot;age&quot;&gt;要增加的年齡&lt;/param&gt; public void AgeAdd(int age) //方法 { this.Age += age; } } static void Main(string[] args) { } } 上面看到我們宣告了一個Person類別，裡面包含了屬性以及方法。接著我們把他建立成一個物件並且存取這個類別提供的方法與屬性 var man = new Person(); //建立man物件，為Person類別 man.Age = 10; //將man物件的Age設為10 Console.WriteLine(man.Age) man.AgeAdd(10); //呼叫增加年齡方法 Console.WriteLine(man.Age) Console.ReadLine(); 存取範圍層級使用存取修飾詞 public、protected、internal 或 private 來指定成員的下列其中一個已宣告存取範圍層級。 已宣告存取範圍 意義 public 未限制存取 protected 存取限於包含類別或衍生自包含類別的類型 internal 存取限於目前組件 private 存取限於包含類型 繼承宣告Man類別繼承Person，類別繼承可以使用父類別的屬性與方法(private除外) public class Man : Person //繼承Person { public int Length { get; set; } } 宣告的Man類別依然可以使用Person類別的值與方法 var man = new Man(); //建立man物件，為Person類別 man.Age = 10; //將man物件的Age設為10 Console.WriteLine(man.Age) man.AgeAdd(10); //呼叫 Console.WriteLine(man.Age) man.Lenght = 30; Console.WriteLine(man.Lenght) Console.ReadLine(); 結構(struct)跳過 陣列(array)陣列是一種資料結構，其中包含一些可透過計算索引存取的變數。 陣列中包含的變數 (也稱為陣列的元素) 屬於相同的型別，這種型別稱為陣列的元素型別。 而陣列變數的宣告只是預留空間給陣列執行個體的參考。 實際的陣列執行個體是執行階段期間使用 New 運算子動態建立。 新增作業會指定新陣列執行個體的長度，這在該執行個體的存留期是固定的。 int[] a = new int[10]; for (int i = 0; i &lt; a.Length; i++) { a[i] = i * i; } for (int i = 0; i &lt; a.Length; i++) { Console.WriteLine($&quot;a[{i}] = {a[i]}&quot;); int[] a1 = new int[10]; //一維 int[,] a2 = new int[10, 5]; //二維 int[,,] a3 = new int[10, 5, 2]; //三維 //不規則陣列 int[][] r = new int[3][]; r[0] = new int[10]; r[1] = new int[5]; r[2] = new int[20]; //直接賦予初始值 int[] init = new int[] { 1, 2, 3 }; int[] init2 = { 1, 2, 3 }; Console.ReadLine(); #介面(interface) 「介面」定義可由類別和結構實作的合約。 介面可以包含方法、屬性、事件和索引子。 介面不提供它所定義之成員的實作 (它只會指定必須由類別提供的成員或實作介面的結構)。 介面可以採用「多重繼承」 下面宣告一個介面和繼承他的類別 public interface Person { void AddAge(); } public class Man : Person//Man 繼承 Person介面 { public void AddAge() //必須實作介面定義的方法 { throw new NotImplementedException(); } } 介面的作用可以用來定義物件開發的規範，也可以用來降低程式耦合來達到軟體設計的高內聚，低耦合(high cohesion、low coupling)概念。 列舉(enum)「列舉型別」是含一組具名常數的相異實值型別。 當您需要定義可擁有一組離散值的型別時，便可定義列舉。 它們使用其中一個整數值型別作為其基礎儲存體。 它們會為離散值提供語意意義。 enum PersonType //PersonType列舉 { Child, //0 Young, //1 Big, //2 Old //3 } static void Main(string[] args) { var type = PersonType.Big; Console.WriteLine($&quot;PersonType enum = {(int)type}&quot;); switch(type) { case PersonType.Child: Console.WriteLine(&quot;Chile&quot;); break; case PersonType.Young: Console.WriteLine(&quot;Young&quot;); break; case PersonType.Big: Console.WriteLine(&quot;Big&quot;); break; case PersonType.Old: Console.WriteLine(&quot;Old&quot;); break; } Console.ReadLine(); } 每個 enum 型別都有對應的整數型別，稱為 enum 型別的「基礎型別」。 未明確宣告基礎型別的 enum 型別會擁有 int 基礎型別。 enum Alignment: sbyte //使用sbyte當作enum型別 { Left = -1, Center = 0, Right = 1 } enum 成員宣告可以包含會指定成員值的常數運算式。 每個 enum 成員的常數值都必須在 enum 的基礎型別範圍內。 當 enum 成員宣告並未明確指定值時，賦予成員的值會是零 (如果它是 enum 型別中的第一個成員) 或是本文上前面 enum 成員的值加 1。 int i = (int)PersonType.Big; // int i = 2; PersonType c = (PersonType)2; // PersonType cPersonType.Big; Console.ReadLine(); 委派(delegate)跳過 C#命名方針(Coding Standard)大小寫慣例若要區分識別項中的文字，將變成大寫識別項中的每個單字的第一個的字母。 請勿使用底線來區分文字，或該項目的，識別項中的任何位置。 有兩個適當的方法可以改為大寫的識別項，根據所使用的識別項： PascalCasing camelCasing 特殊案例對兩個字母縮略字，這兩個字母都大寫，如下列的識別項中所示： IOStream 三個以上則使用Pascal XmlString 基本上Field (Private)(加上底線) _name，Local Variable，Parameter是用camel命名，其他都是用pascal 一般命名慣例✓ 選擇簡單易讀的識別項名稱。 例如，名為的屬性HorizontalAlignment是英文-可讀性比AlignmentHorizontal。 ✓ 勝過求簡單明瞭的可讀性。 屬性名稱CanScrollHorizontally優於ScrollableX（x 軸之下參考）。 X 不使用底線、 連字號或任何其他非英數字元。 X 不使用匈牙利標記法。 X 不縮寫做為識別項名稱的一部分。 例如，使用GetWindow而不是GetWin。 ✓ 語意方面有意義的名稱，而不是語言特有的關鍵字用於型別名稱。 例如，GetLength是更適合的名稱，比GetInt。 Interface 使用前置詞”I” Property 避免使用”Get”或”Set”當前置詞 相關文章C#初階教學]]></content>
      <categories>
        <category>程式開發教學</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>新手教學</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown教學]]></title>
    <url>%2F2018%2F04%2F20%2FMarkdown%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[Markdown介紹Markdown是一種文字轉Html的語法 Markdown的目標是實現「易讀易寫」。 為什麼使用Markdown 容易寫 寫Markdown比寫Html容易，不需要會Html也可以產生Html的內容 容易讀 某些環境你沒辦法開啟IDE去看你的Html或的Word文章只能開txt檔時，你還可以容易看得出來你文章的結構以及內容是甚麼 一致性 在多人共同作業時每個人寫出來的Html可能都有誤差，以至於風格不一，使用Markdown會產生相同的格式再由統一的css樣式表就可以輕鬆統一訂製網頁風格 書寫提示 Mardown語法裡面可以直接使用html標籤 記得Markdown的標籤大部分都需與你的文字有一個空格 ex. # ABC 區塊元素比如&lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;等標籤需要與前後文有一行空行 This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. 段落與引言段落文字區塊段落主要用一個以上的空行來表示也可以用兩個空白來表示強制插入&lt;br/&gt; 文章主要段落有兩種寫法使用 使用===(數量不限)寫在文字下方 ===為1階標題 —為2階標題 使用# 來表示段落 最多6個 段落1 ===== 段落2 ----- # 段落1 ## 段落2 ### 段落3 #### 段落4 ##### 段落5 ###### 段落6 段落1段落2段落1段落2段落3段落4段落5段落6引言引言使用&gt;加在文字前面來表示類似email格式的引言區塊，可使用多個&gt;來表示引言階層 例如&gt; &gt; &gt; 這是引言 &gt; 這是引言 &gt; &gt; &gt; 這是引言中的引言 &gt; &gt; 這是引言 &gt; 這是引言 這是引言這是引言 這是引言中的引言 這是引言這是引言 清單 無順序的清單使用 * + - 來表示 有順序的清單使用數字加句點表示 1. (數字順序不影響顯示出來的內容，顯示出來一定為1. 2. 3. 4.) * 清單1 * 清單2 * 清單3 清單1 清單2 清單3 1. 清單1 2. 清單2 3. 清單3 1. 清單1 1. 清單2 1. 清單3 清單1 清單2 清單3 清單1 清單2 清單3 表格使用 | 來分隔欄位 使用 - 來分隔標題 使用 : 來表示內容對齊，也可以不使用，預設靠左 為了Markdown語法美觀可自行對齊 | 實際上語法內可以不用對齊(如下程式碼最後一行) 目前MD不支援合併儲存格，有需要請使用Html | left | center | right | default | | :--- | :----: | ----: | ------ | | a | b | c |d | |a|b|c|d| left center right default a b c d a b c d 文字格式使用 * 或 _ 來將你的文字包起來做強調或著使用 ~~ 來加刪除縣 **Blod** *Italic* ***Bold and Italic*** ~~Delete~~ Blod Italic Bold and Italic Delete 分隔線一行中使用三個以上的 * - _ 來表示分隔線&lt;hr/&gt; --- ******* _______________ 程式碼使用3個 ` 包圍你的程式碼區塊也可以是一行文字 ```區塊可以在後面加上語法名稱例如 cs，md，html來表示你的語法(本站使用highlight.js來高亮語法) 附上常用語言代碼參考 程式語言 代碼 Bash bash, sh C# cs, csharp C++ cpp, c, c++ CSS css HTML, XML html, xml, xhtml, rss JSON json JAVA java, jsp JAVASCRIPT javascript, js MARKDOWN markdown, md R r SQL sql ``` cs class Program { static void Main(string[] args) { // Create an object of type CustomClass. CustomClass custClass = new CustomClass(); // Set the value of the public property. custClass.Number = 27; // Call the public method. int result = custClass.Multiply(4); Console.WriteLine($&quot;The result is {result}.&quot;); } } ` ` ` 此行為了示範把`分開 實際上是要打在一起 class Program { static void Main(string[] args) { // Create an object of type CustomClass. CustomClass custClass = new CustomClass(); // Set the value of the public property. custClass.Number = 27; // Call the public method. int result = custClass.Multiply(4); Console.WriteLine($&quot;The result is {result}.&quot;); } } 連結超連結常用分為行內以及參考兩種方法 使用[ ]將文字包起來 ( )將連結網址放在裡面 使用兩個 [ ][ ] 前面為文字後面為參考的id，參考的超連結分開使用 [id]: 連結 “tooltip文字” 的格式來寫來寫 This is [Google](http://www.google.com) Link This is [Google][0] Link [0]: http://www.google.com &quot;tooltip&quot; This is Google Link This is Google Link 圖片超連結常用分為行內以及參考兩種方法 使用![ ]將文字包起來 ( )將圖片網址放在裡面 使用兩個 ![ ][ ] 前面為文字後面為參考的id，參考的超連結分開使用 [id]: 連結 “tooltip文字” 的格式來寫 ![Alt text](Markdown.png) ![Alt text][logo] [logo]: Markdown.png &quot;tooltip&quot;]]></content>
      <categories>
        <category>其他教學文件</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#初階教學]]></title>
    <url>%2F2018%2F04%2F20%2FCsharp%E5%88%9D%E9%9A%8E%E6%95%99%E5%AD%B81%2F</url>
    <content type="text"><![CDATA[本教學以C#基礎語法教學為主搭配VS2017開發環境。 以下皆以console程式作範例，主要內容來自MSDN 控制台應用程式（console application）是一種設計用於純文字電腦介面的電腦程式 C#簡介準備開發環境安裝Visual Studio安裝VisualStudio，Community 2017 版本即可 並且選擇要開發的項目來選擇安裝，全選會需要非常多的空間，沒有必要，基本上選擇.NET桌面開發、ASP.NET網頁開發(有要開發網頁的話)、資料儲存與處理、其他再視個人需求勾選。 開啟你的第一個專案 Hello World開啟VS2017後左上角選單選擇 檔案 -&gt; 新增 -&gt; 專案，在專案選擇畫面左邊為Visual C#類別，右邊選擇主控台應用程式(.NET Framework)，下方為你的專案取個名字選擇存放資料夾按下確定 建立專案後右側為方案總管，是負責設定程式參數以及管理程式碼和參考的地方 在Program.cs的Main裡面寫上Hello world看看執行結果 static void Main(string[] args) { Console.WriteLine(&quot;Hello World&quot;); Console.ReadLine(); //Pause } =========== 程式結構C# 程式包含一個或多個原始程式檔。 程式宣告型別，其中包含成員並可以依據命名空間分組。 類別和介面都是型別的範例。 欄位、方法、屬性及事件都是成員的範例。 在VS中每一個方案(solution)可以包含許多專案(project)，每一個專案包含許多的程式碼檔案以及資源，一個專案編譯完成為一個組件，組件基本為執行檔(exe)或程式庫(dll)。 通常較為大型的程式會由一個exe與許多dll組成，我們將軟體架構拆分為許多的dll再交由exe統整應用。 C# 語言的重要組織概念如下：程式、命名空間、型別、成員及組件。 C# 程式包含一個或多個原始程式檔。 程式宣告型別，其中包含成員並可以依據命名空間分組。 類別和介面都是型別的範例。 欄位、方法、屬性及事件都是成員的範例。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; //參考 Reference namespace ConsoleApp1 //命名空間 namespace { class Program //型別 class and interface { string _userName; //屬性 Property public Program() //建構式 constructor { } static void Main(string[] args) //方法 method { Console.WriteLine(&quot;Hello World&quot;); Console.ReadLine(); } } } 參考: 程式參考哪些組件、類別 命名空間: 型別存在的命名空間，用來類別分組使用，ConsoleApp1.Program為範例類別完整名稱 型別: 宣告程式型別的類型，通常為類別(class)或介面(interface) 屬性: 為類別成員的一種，屬性是提供彈性機制以讀取、寫入或計算私用欄位值的成員 建構式: 每當建立類別或結構時，都會呼叫其建構函式。 類別或結構可有使用不同引數的多個建構函式。 方法: 方法是包含一系列陳述式的程式碼區塊。 程式會造成呼叫方法並指定任何所需的方法引數來執行陳述式。 ============== 類型與變數跳過 ============== 運算式「運算式」是由「運算元」和「運算子」建構而成。 運算式的運算子會指出要將哪些運算套用到運算元。 運算子範例包括 +、-、*、/ 及 new。 運算元範例包括常值、欄位、區域變數及運算式。 除了指派運算子之外，所有二元運算子都具有「左關聯性」，亦即會由左到右執行運算。 例如，x + y + z 會判斷值為 (x + y) + z。 指派運算子和條件運算子 (?:) 具有「右關聯性」，亦即會由右到左執行運算。 例如，x = y = z 會判斷值為 x = (y = z)。 Console.WriteLine($&quot;1 + 2 = { 1 + 2 }&quot;); //加法 Console.WriteLine($&quot;2 - 1 = { 2 - 1 }&quot;); //減法 Console.WriteLine($&quot;2 * 3 = { 2 * 3 }&quot;); //乘法 Console.WriteLine($&quot;4 / 2 = { 4 / 2 }&quot;); //除法 Console.WriteLine($&quot;4 % 2 = { 4 % 2 }&quot;); //餘數 Console.WriteLine(); Console.WriteLine($&quot;1 + 2 = { 1 + 2 }&quot;); //二元運算子順序從左到右 Console.WriteLine($&quot;1 + 2 * 3= { 1 + 2 * 3}&quot;); //* 運算子的優序高於 + Console.WriteLine(); var x = 1; var y = 2; var z = 3; Console.WriteLine($&quot;x=1, y=2, z=3 x = y = z =&gt;{x = y = z}&quot; //指子從右到左 Console.WriteLine(); x = 1; y = 2; z = 2; Console.WriteLine(&quot;關係和型別測試&quot;); Console.WriteLine(&quot;x = 1; y = 2; z = 2&quot;); Console.WriteLine($&quot;x &gt; y =&gt;{x &gt; y}&quot;); //大於 Console.WriteLine($&quot;x &lt; y =&gt;{x &lt; y}&quot;); //小於 Console.WriteLine($&quot;y &gt;= x =&gt;{y &gt;= x}&quot;); //大於等於 Console.WriteLine($&quot;y &lt;= z =&gt;{y &lt;= z}&quot;); //小於等於 Console.WriteLine($&quot;x == y =&gt;{x == y}&quot;); //等於 Console.WriteLine($&quot;x == y =&gt;{x != y}&quot;); //不等於 Console.WriteLine(); Console.WriteLine(&quot;x=1&quot;); Console.WriteLine($&quot;x++ =&gt;{x++}&quot;); //++為遞增 --為遞減 放在值後後置遞行順序為先執行程式後遞增 Console.WriteLine($&quot;x =&gt;{x}&quot;); //執行完上一行的程式後 x遞增 Console.WriteLine($&quot;++x =&gt;{++x}&quot;); //++放在值前面前置遞增，先進增才執行容 Console.WriteLine(); var a = true; var b = false; Console.WriteLine(&quot;邏輯 條件&quot;); Console.WriteLine(&quot; a = true b = false&quot;); Console.WriteLine($&quot;!a =&gt; {!a}&quot;); //邏輯否定 傳回相反邏輯 Console.WriteLine($&quot;a &amp;&amp; b =&gt; {a &amp;&amp; b}&quot;); //條件式 AND Console.WriteLine($&quot;a || b =&gt; {a || b}&quot;); //條件式 OR Console.ReadLine(); 陳述式程式的動作是藉由陳述式來表達。 C# 支援數種不同類型的陳述式，其中一些是以內嵌陳述式來定義。 「區塊」可允許在許可單一陳述式的內容中撰寫多個陳述式。 區塊是由在 { 與 } 分隔符號之間撰寫的陳述式清單所組成。 當變數宣告在區塊內就是區域變數，在區塊外的無法存取到區塊內的區域變數 var variable = &quot;Variable&quot;; { var localVariable = &quot;Local variable&quot;; //區域變數 Console.WriteLine(variable); Console.WriteLine(localVariable); Console.WriteLine(variable); Console.WriteLine(localVariable); //此行無法編譯localVariable被宣告在上面的區塊中，只有在那個區塊中可以使用 Console.ReadLine(); if 陳述式if 陳述式會根據運算式的 Boolean 值識別要執行的陳述式。 var count = 0; if (count == 0) //如果條件成立程式會進入下面區塊，並且跳過其他判斷條件 { Console.WriteLine(&quot;count = 0&quot;); } else if (count == 1) //上述條件都不成立，到此判斷條件是否成立 Console.WriteLine(&quot;count = 1&quot;); } else //所有條件都不成立 { Console.WriteLine(&quot;other&quot;); } switch 陳述式switch 是一個選取範圍陳述式，可根據使用「比對運算式」的模式比對，從候選項清單中選擇要執行的單一「參數區段」。 在 C# 6 中，比對運算式必須是傳回下列類型之值的運算式︰ char。 string。 bool。 整數值，例如 int 或 long。 enum 值。 從 C# 7 開始，比對運算式可以是任何非 Null 運算式。 常數模式常數模式會測試比對運算式是否等於指定的常數。 switch (DateTime.Now.DayOfWeek) //switch放入變數作為判斷條件 { case DayOfWeek.Sunday: //當DateTime.Now.DayOfWeek為星期天 case DayOfWeek.Saturday: //星期六，可將多個條件同時寫在一起 Console.WriteLine(&quot;The weekend&quot;); break; //陳述式結束 case DayOfWeek.Monday: Console.WriteLine(&quot;The first day of the work week.&quot;); break; case DayOfWeek.Friday: Console.WriteLine(&quot;The last day of the work week.&quot;); break; default: //不在上面的條件中會執行此段，也可以省略不寫，基本上類if陳述式中的else區塊 Console.WriteLine(&quot;The middle of the work week.&quot;); break; Console.ReadLine(); 類型模式類型模式會啟用精簡類型評估和轉換。 與 switch 陳述式搭配使用來執行模式比對時，會測試運算式是否可轉換成指定的類型；如果可以的話，則會將它轉換成該類型的變數。 static void Main(string[] args) { int[] values = { 2, 4, 6, 8, 10 }; ShowCollectionInformation(values); var names = new List&lt;string&gt;(); names.AddRange(new string[] { &quot;Adam&quot;, &quot;Abigail&quot;, &quot;Bertrand&quot;,&quot;Bridgette&quot; }); ShowCollectionInformation(names); List&lt;int&gt; numbers = null; ShowCollectionInformation(numbers); Console.ReadLine(); } private static void ShowCollectionInformation(object coll) { switch (coll) { case Array arr: //判斷object是否為Array類型 Console.WriteLine($&quot;An array with {arr.Length}elements.&quot;); break; case IEnumerable&lt;int&gt; ieInt: Console.WriteLine($&quot;Average: {ieInt.Average(s =&gt; s)}&quot;; break; case IList list: Console.WriteLine($&quot;{list.Count} items&quot;); break; case IEnumerable ie: string result = &quot;&quot;; foreach (var item in ie) result += &quot;${e} &quot;; Console.WriteLine(result); break; case null: // Do nothing for a null. break; default: Console.WriteLine($&quot;A instance of type {coll.GetType(.Name}&quot;); break; } } while 陳述式while 陳述式會執行陳述式或陳述式區塊，直到指定的運算式評估為 false 為止。 int n = 1; while (n &lt; 6) //當條件不成立時才會離開while區塊，所以使用時要小心造成無限迴圈 { Console.WriteLine(&quot;Current value of n is {0}&quot;, n); n++; //當沒有此行程式碼時，會形成無限迴圈的情況，永遠重複此區塊程式碼 } Console.ReadLine(); do 陳述式類似while陳述式，但會先執行do區塊內的程式碼才進行while判斷 int n = 10; do //會先執行此區塊內容才進行下面while判斷 { Console.WriteLine(n); } while (n&lt;5); Console.ReadLine(); for 陳述式透過 for 迴圈，您可以重複執行陳述式或陳述式區塊，直到指定的運算式評估為 false 為止。 這種迴圈對於逐一查看陣列很有用，也適用於您事先知道迴圈要反覆運算幾次的其他應用。 //for (initializer; condition; iterator) //for結構為 初始值;條件判斷;迭代器區段 int limit = 10; for (int i = 0; i &lt; limit; i++) { Console.WriteLine(i); } Console.ReadLine(); foreach 陳述式foreach 陳述式會為陣列或物件集合中每個實作 System.Collections.IEnumerable 或 System.Collections.Generic.IEnumerable 介面的每個元素，重複一組內嵌陳述式。 foreach 陳述式可用來逐一查看集合，以取得所需的資訊，但不能用來新增或移除來源集合中的項目，以避免無法預期的副作用。 var users = new List&lt;string&gt;() { &quot;A&quot;, &quot;B&quot;, &quot;C&quot; }; foreach (string s in users) { Console.WriteLine(s); } Console.ReadLine(); break 陳述式break 陳述式會終止其所在的最接近封閉式迴圈或 switch 陳述式。 while (true) { Console.WriteLine(&quot;Test&quot;); break; //執行到此行直接終止並且離開此區塊 } Console.ReadLine(); continue 陳述式continue 陳述式會將控制權轉移給其所在的封閉式 while、do、for 或 foreach 陳述式的下一個反覆項目。 for (int i = 1; i &lt;= 10; i++) { if (i &lt; 9) { continue; //執行到此終止並且進到下一此迴圈 } Console.WriteLine(i); } Console.ReadLine(); throw 陳述式和 try 陳述式try-catch 陳述式包含 try 區塊後面接著一個或多個 catch 子句，指定不同例外狀況的處理常式。 static void ProcessString(string s) { if (s == null) { throw new ArgumentNullException(); //拋出ArgumentNullException } } static void Main() { try { string s = null; ProcessString(s); } // Most specific: catch (ArgumentNullException e) //擷取ArgumentNullException例外 { Console.WriteLine(&quot;{0} First exception caught.&quot;, e); } // Least specific: catch (Exception e) //擷取所有例外 { Console.WriteLine(&quot;{0} Second exception caught.&quot;, e); } finally //try catch結束後會執行 { //常見的搭配使用 catch 與 finally 是要取得和使用 try 區塊中的資源、處理 catch 區塊中的例外情況，以及釋放 finally 區塊中的資源。 //do something.... } } using 陳述式提供方便的語法，以確保正確使用 IDisposable 物件。 //using 結束後會釋放TextWriter資源 using (TextWriter w = File.CreateText(&quot;test.txt&quot;)) { w.WriteLine(&quot;Line one&quot;); w.WriteLine(&quot;Line two&quot;); w.WriteLine(&quot;Line three&quot;); } goto 陳述式goto 陳述式會將程式控制權直接轉移到標記陳述式。 goto 的一個常見用法是將控制權轉移到特定的切換案例標籤，或 switch 陳述式中的預設標籤。 goto 陳述式也適用於跳出深度巢狀的迴圈。 int i = 0; goto check; loop: Console.WriteLine(args[i++]); check: if (i &lt; args.Length) goto loop; 以下功用較複雜，先跳過 return 陳述式yield 陳述式checked 和 unchecked 陳述式lock 陳述式相關文章C#初階教學2]]></content>
      <categories>
        <category>程式開發教學</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>新手教學</tag>
      </tags>
  </entry>
</search>
